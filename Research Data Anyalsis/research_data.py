# -*- coding: utf-8 -*-
"""Research Paper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jHZaTP2piJRYI8Xm2qFvwxCda0JvCzuR
"""

# For reading file location
import os
# For data analysis
import pandas as pd
# For mathematical calculation
import numpy as np
# For plotting graphs
import matplotlib.pyplot as plt
# For using color in graphs
import matplotlib.colors as mcolors
# For data visualization
import seaborn as sns
# For helping to detect columns names by matching text with it
import re
# For adding grid lines
from matplotlib.gridspec import GridSpec

# Connecting my google Drive with Google Colab
from google.colab import drive
drive.mount('/content/drive')

# Load reasearch data into google colab
data=pd.read_csv('drive/My Drive/ResearchData/data.csv')

# Displaying data to check whether file was loaded
data.head()

# Listed the IDs that need to be removed from data
Discarded_IDS = {
    "15.09.15.13",
    "16.09.15.15",
    "16.09.15.43+ 16.09.15.44",
    "16.09.17.07",
    "17.09.12.32",
    "17.09.15.55",
    "17.09.16.35",
    "17.09.17.24",
}

# Assigning variables to column names so it can be called in code
COL_CONVO_ID = "Conversation ID"
COL_AGE_21   = "Are you 21 years or older?"

# ─── Data cleaning ────────────────────────────────────────────────

def clean_dataframe(data):
    # Conversation ID normalized by removing unnecessary spaces
    convo = data[COL_CONVO_ID].astype(str).str.strip()

    # removes rows where Conversation ID contains test
    mask_test = convo.str.lower().str.contains("test", na=False)

    # Age normalized by removing unnecessary spaces
    age = data[COL_AGE_21].astype(str).str.strip().str.lower()
    # Keep data if Yes is there
    mask_over21 = age.eq("yes")

    # Checks if any rows match the discarded ID mentioned
    mask_banned = convo.isin(Discarded_IDS) if Discarded_IDS else False

    # Provides cleaned data
    return data[~mask_test & mask_over21 & ~mask_banned].copy()

# Applies function to data and saves it as df
df = clean_dataframe(data)

# Display data
df.head()

# Check if any banned IDs still there
checking_IDs = df[df["Conversation ID"].isin(Discarded_IDS)]
# Prints the result
if checking_IDs.empty:
    print("All Discarded IDs removed.")
else:
    print("Still found banned IDs:", checking_IDs["Conversation ID"].tolist())

# Check if any banned IDs still there
if (df["Are you 21 years or older?"].str.strip().str.lower() != "yes").any():
  # Prints the result
    print("Found rows with 'No' in 21+ column")
else:
    print("All rows are 21+")

mask_test = df["Conversation ID"].str.lower().str.contains("test", na=False)
# Check if any banned IDs still there
# Prints the result

if mask_test.any():
    print("Found test IDs:", df.loc[mask_test, "Conversation ID"].tolist())
else:
    print("No test IDs")

"""Analysis"""

# Setting the questions from data
LIKERT_COLS = [
    "The robot was able to understand the question I asked",
    "I feel satisfied with the answer provided as it properly addressed my question",
    "The robot was able to understand the tone of what I had asked to it (positive or negative)",
    "I feel the robot responded to question in a way that matched the intended meaning of my question",
    "The robot was able to answer my question well even when I asked an indirect or vague question",
    "I feel that the robot’s response was relevant to the question I had asked even when I had asked random questions",
]


# Short labels to display questions
SHORT_LABELS = [
    "Q2 Able to understand the question I asked",
    "Q3 Satisfied with the answer - properly addressed my question",
    "Q4 Able to understand the tone of question (positive or negative)",
    "Q5 Response matched the intended meaning of my question",
    "Q6 Able to answer indirect or vague question",
    "Q7 Response relevant to random questions",
    "Q8 Overall Satisfaction",
]

# Variable for setting overall satisfaction question
COL_OVERALL_TXT = "Overall satisfaction about the interaction with the robot"
# Learning Point: This question was not being displayed when it was with other short labels so I added separately
# Reason for this was that other questions had number answer but overall satisfaction has text answer

# Combining all questions into 1 variable
all_cols = LIKERT_COLS + ["Overall (1-5)"]

# Variable for setting overall satisfaction question
OVERALL_NUM_COL = "Overall (1-5)"
# Mapping overall satisfaction answers to number
OVERALL_MAP = {"excellent": 5, "great": 4, "good": 3, "average": 2, "poor": 1}

# Function for fixing issue with overall satisfaction column
def get_overall_col(df: pd.DataFrame) -> str:
    # Uses the re library for matching the column name
    # ^overall indicates to match string values
    # \s* to allow for space to be there and would not get affected
    # .* indicated that it must include satisfaction interaction robot string
    # re.I allows search to not be sensitive to capital letters
    pat = re.compile(r"^overall\s*satisfaction.*interaction.*robot", re.I)
    # Loops through all the columns names
    for c in df.columns:
      # If pattern is found
        if pat.search(str(c)):
            # make a clean name
            df.rename(columns={c: "Overall satisfaction about the interaction with the robot"}, inplace=True)
            return "Overall satisfaction about the interaction with the robot"
    raise KeyError("Overall column not found.")
    # Learning point: Was having an issue with this column due to format issues coming from Google Sheets

# Apply function
overall_col = get_overall_col(df)

# Convert text response to numeric
df["Overall (1-5)"] = (
    df[overall_col].astype(str).str.strip().str.lower().map(OVERALL_MAP)
)

# Display text results in that column
print("Overall unique (cleaned):", df[overall_col].astype(str).str.strip().str.lower().unique())
# Display count of results in number format
print("Overall (1-5) value_counts:", df["Overall (1-5)"].value_counts(dropna=False))

# Poor is not shown in table below as no participant gave that rating for Overall

# Function to make sure results are in numeric format
def coerce_likert_numeric(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    # Loop through data in columns
    for c in cols:
      # Ensures values are numeric (and not string) so we can do calculation
      # If there is an error, it will make it NaN which is null
        df[c] = pd.to_numeric(df[c], errors="coerce").clip(lower=1, upper=5)
    return df

# Function to make sure results are in numeric format
def map_overall_to_numeric(df: pd.DataFrame, src_col: str, dst_col: str = "Overall (1-5)") -> pd.DataFrame:
    # Cleans the data by removing spaces and making lower case
    df[dst_col] = (
        df[src_col]
        .astype(str)
        .str.strip()
        .str.lower()
        # Maps the string values to numeric results
        .map(OVERALL_MAP)
    )
    return df

# Function for creating distribution graph for each question
def plot_distribution(series: pd.Series, title: str):
    # Clean data so it is ready to be plotted
    s = series.dropna().astype(str).str.strip().str.lower()

    # If value is numeric
    if s.str.isnumeric().all():
        # make data type to be integer
        s = s.astype(int)
        # make label order to be as below
        counts = s.value_counts().reindex([1,2,3,4,5], fill_value=0)

    # If it is string values
    else:
      # Set label order
        label_order = ["poor", "average", "good", "great", "excellent"]
        # make label order to be as below
        counts = s.value_counts().reindex(label_order, fill_value=0)
    # Plot figure
    plt.figure()
    # set type to be bar graph
    counts.plot(kind="bar")
    # Set title
    plt.title(title)
    # Set labels
    plt.xlabel("Score")
    plt.ylabel("Count")
    # make graph fitted
    plt.tight_layout()
    # show graph
    plt.show()

all_cols = LIKERT_COLS + [COL_OVERALL_TXT]

#Loop through all columns and plot graph
for col in all_cols:
    plot_distribution(df[col], f"Distribution: {col}")

# Function for combining bar graphs
def plot_grouped_bar_with_labels_horizontal(
    # Setting data frame to use
    df: pd.DataFrame,
    # Setting questions to be displayed
    likert_cols: list[str],
    # Setting labels
    display_labels: list[str],
    # Setting column name for overall satisfaction
    overall_text_col: str,
    # Setting values for overall satisfaction
    overall_num_col: str = "Overall (1-5)",
    # For Mapping text values to number values
    overall_map: dict | None = None,
    # Setting label for overall satisfaction
    overall_label_text: str = "Overall Satisfaction",
    # Ensures questions doesn't get skipped
    include_overall: bool = True,
    # Puts first question of Q2 at top
    reverse_order: bool = True,
    # Graph Title
    title: str = "Response Distribution by Question (Horizontal)"
):
    # Loop to ensure the text values are properly getting mapped to numeric values
    if overall_map is None:
        overall_map = {"excellent":5, "great":4, "good":3, "average":2, "poor":1}

    # Loop to check whether overall column with numeric values exits and ensure to include it
    if include_overall and overall_num_col not in df.columns:
      # Checks if the overall column is there but just with the text values
        if overall_text_col not in df.columns:
          # If it is not there, display error
            raise KeyError(f"Column '{overall_text_col}' not found in DataFrame")
        # Otherwise covert the text values to numeric values
        df[overall_num_col] = (
            df[overall_text_col].astype(str).str.strip().str.lower().map(overall_map)
        )

    # Setting list of questions from columns
    question_cols = list(likert_cols)
        # Add overall satisfactions question if it is marked true at include_overall
    if include_overall:
        question_cols.append(overall_num_col)

    # Setting display labels
    labels = list(display_labels)
        # Check if the number of labels matched the number of questions
    if len(labels) != len(question_cols):
        # If it does match number BUT if adding overall satisfaction question and number of labels DO match
        if include_overall and len(labels) + 1 == len(question_cols):
              # Then just add overall satisfaction questions to label
            labels.append(overall_label_text)
        # Otherwise display error
        else:
            raise ValueError("display_labels length must match question_cols length")

    # Calculates the percentage of each block in bar graph
    def pct_series(s: pd.Series) -> pd.Series:
        # Ensure all values are numeric so calculation can be done
        s = pd.to_numeric(s, errors="coerce")
        # Checks number of NaN values
        n = s.notna().sum()
        # If NaN values are there
        if n == 0:
            # Given 0 for all scores
            return pd.Series({k: 0.0 for k in [1,2,3,4,5]})
        # Otherwise calculate percentage of each score
        return pd.Series({k: (s.eq(k).sum() / n) * 100.0 for k in [1,2,3,4,5]})

    # Apply function to each question
    dist_df = df[question_cols].apply(pct_series).T

    # Sets the order so Q2 comes on top
    if reverse_order:
        dist_df = dist_df.iloc[::-1]
        labels = labels[::-1]

    # Creates the plot
    # barh = horizontal bar chart
    ax = dist_df.plot(
        kind="barh", stacked=True, figsize=(10, 6),
        colormap="viridis", edgecolor="black"
    )

    # Draw Grid lines on graph
    for x in [20, 40, 60, 80, 100]:
        plt.axvline(x, color="gray", linestyle="--", linewidth=0.7)

    # Adds percentage in bar graph
    for container in ax.containers:
        for bar in container:
            # Gets the width of bar
            w = bar.get_width()
            # Only if bar is greater than 5 - Then show the percentage values
            if w > 5:
                x = bar.get_x() + bar.get_width()/2
                y = bar.get_y() + bar.get_height()/2
                rgb = mcolors.to_rgb(bar.get_facecolor())
                # Calculate brightness to decide whether black or white font color should be used
                brightness = 0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2]
                # Setting text for percentage values and decision making of font color
                ax.text(x, y, f"{w:.1f}%", ha="center", va="center",
                        fontsize=8, color=("black" if brightness > 0.6 else "white"),
                        weight="bold")
    # Sets labels and titles
    ax.set_yticklabels(labels, fontsize=9)
    plt.title(title, fontsize=14, pad=15)
    plt.xlabel("Percentage of Responses")
    plt.ylabel("Question")
    # Sets legend on the side
    plt.legend(title="Score", bbox_to_anchor=(1.05, 1), loc="upper left")
    plt.show()

# Applies the function to display graph
# Set as the parameter mentioned in function
plot_grouped_bar_with_labels_horizontal(
    df=df,
    likert_cols=LIKERT_COLS,
    display_labels=SHORT_LABELS,
    overall_text_col=COL_OVERALL_TXT,
    overall_num_col=OVERALL_NUM_COL,
    overall_map=OVERALL_MAP,
    overall_label_text="Overall Satisfaction",
    include_overall=True,
    title="Response Distribution by Question"
)

# Function for ensuring overall satisfaction is in numeric
def ensure_overall_numeric(df: pd.DataFrame,
                           text_col: str,
                           num_col: str = "Overall (1-5)",
                           mapping: dict | None = None) -> None:
    # If mapping is not found - apply below mapping
    if mapping is None:
        mapping = {"excellent": 5, "great": 4, "good": 3, "average": 2, "poor": 1}
    # If numeric column for overall satisfaction does not exist
    if num_col not in df.columns:
      # Apply mapping
        df[num_col] = (
            df[text_col].astype(str).str.strip().str.lower().map(mapping)
        )

# Function for creating horizontal box plots
def plot_boxplots_horizontal(df: pd.DataFrame,
                             question_cols: list[str],
                             display_labels: list[str],
                             title: str = "Distributions by Question (Box Plot, Horizontal)"):
    # Checks whether number of column matches labels
    if len(question_cols) != len(display_labels):
      # If not, display error
        raise ValueError("display_labels length must match question_cols length")
    # Converts values into numeric
    # errors="coerce"  means if you can't convert, make it NaN instead of crashing it
    data = df[question_cols].apply(pd.to_numeric, errors="coerce")

    # Setting plot sizing and labels
    plt.figure(figsize=(10, 6))
    plt.boxplot(
        # Dropping NaN values
        [data[c].dropna() for c in question_cols],
        labels=display_labels,
        vert=False,
        patch_artist=True,
        widths=0.6,
        whis=1.5
    )
    # Setting plot labels and titles
    plt.xlim(1, 5)
    plt.xlabel("Score (1–5)")
    plt.ylabel("Question")
    plt.title(title, fontsize=14, pad=10)
    plt.grid(axis="x", linestyle="--", alpha=0.35)
    plt.tight_layout()
    plt.show()

#Function for calculating Stats Table
def _stats_for_series(s: pd.Series) -> dict:
    #Convert Values to numeric and drop NaN
    s = pd.to_numeric(s, errors="coerce").dropna()
    # If no values are there in row, show all statistics is NaN to indicate error
    if s.empty:
        return dict(count=0, mean=np.nan, median=np.nan, std=np.nan,
                    Q1=np.nan, Q3=np.nan, IQR=np.nan, skew=np.nan, top2=np.nan)

    # Calculate first and third quartiles
    q1 = s.quantile(0.25); q3 = s.quantile(0.75)
    # Calculate values for table
    return dict(
        count = int(s.size),
        mean  = round(s.mean(), 2),
        median= round(s.median(), 2),
        std   = round(s.std(ddof=1), 2) if s.size > 1 else 0.0,
        Q1    = round(q1, 2),
        Q3    = round(q3, 2),
        IQR   = round(q3 - q1, 2),
        skew  = round(s.skew(), 2),
        top2  = round((s.ge(4).mean() * 100), 1)  # % of 4–5
    )

# Function for displaying table
def build_stats_table_df(df: pd.DataFrame,
                         question_cols: list[str],
                         display_labels: list[str]) -> pd.DataFrame:
    # Checks whether the number of labels matches number of questions
    if len(question_cols) != len(display_labels):
        raise ValueError("display_labels length must match question_cols length")

    # Ensures values are numeric
    data = df[question_cols].apply(pd.to_numeric, errors="coerce")
    # Sets list to hold statistics
    rows = []
    # Loop through each question
    for col, label in zip(question_cols, display_labels):
        # Compute statistics for each question
        rows.append({"Question": label, **_stats_for_series(data[col])})
    # Stores the results in variable
    out = pd.DataFrame(rows)
    # Sets order for results
    return out[["Question","count","mean","median","std","Q1","Q3","IQR","skew","top2"]]

# Checks whether the number of labels matches number of questions
if len(SHORT_LABELS) + 0 == len(LIKERT_COLS):
    # Sets short labels for graph
    SHORT_LABELS = SHORT_LABELS + ["Overall Satisfaction"]

# Ensures all questions are in variable
all_cols = LIKERT_COLS + [OVERALL_NUM_COL]

# Applies the function for graph
plot_boxplots_horizontal(
    df=df,
    question_cols=all_cols,
    display_labels=SHORT_LABELS,
    title="Response Distributions by Question (Horizontal Boxplot)"
)

# Applies function for statistics table
table_df = build_stats_table_df(df, all_cols, SHORT_LABELS)
# Display table
print(table_df.to_string(index=False))
